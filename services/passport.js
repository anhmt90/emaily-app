const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;
const mongoose = require('mongoose');
const keys = require('../config/keys');

const absoluteURI = process.env.NODE_ENV === 'production' ? 'http://emaily-app-v01.herokuapp.com': 'http://localhost:8080';
/**
 * moogoose.model() with 1 arg means FETCHING model
 * moogoose.model() with 2 args means PUSH model into mongoose
 * 
 * User is a MODEL CLASS (not a model instance) associated with a collection inside mongodb
 * 
 * Reason that we don't import/require User.js as we commonly do is explain in vid <VI.9 Saving Model Intances>
 */
const User = mongoose.model('users');

/**
 * Serialize user object to an access token (i.e. cookie)
 * The user param is the user pulled out from the mongodb when the user logs in
 * 
 * the user.id in done() callback is the id generated by mongodb, not the id from Google,
 * the reason for this is that we can expand the auth for other auth providers e.g. facebook, amazon, 
 * etc. later on, so we cannot assume that every user has Google's profile ID. Another reason is,
 * after the auth flow, we won't use the profile ID any longer
 */
passport.serializeUser((user, done) => {
	done(null, user.id);
});


/**
 * Turn an id to a mongoose User model instance
 */
passport.deserializeUser((id, done) => {
	User.findById(id)
		.then((user => { done(null, user); }));
});


/**
 * Tell passport to use a specific strategy: the GoogleStrategy
 * Go to: https://console.developers.google.com/ to create a OAuth client
 */
passport.use(
	new GoogleStrategy({
		clientID: keys.googleClientID,
		clientSecret: keys.googleClientSecret,
		/**
		 * 1st cause: relative path makes Google Authorized redirect URI to be HTPP (instead of HTTPS)
		 * 2nd cause: The GoogleStrategy assumes that requests from browser ever went through any type
		 * 				of proxy, then the request should no longer be HTTPS.
		 * (More on this in vid V.6)
		 * Solution: Add config option `proxy: true` to GoogleStrategy to tell it to trust any proxies that the
		 * 				browser encounters
		 * Alt. solution: spell out the absolute google callback path to Heroku server
		 */
		callbackURL: absoluteURI + '/auth/google/callback',
		/**
		 * Fixing Google redirect URI converted to HTTP instead of HTTPS when
		   * deployed on Heroku
		   */
		proxy: true
	}, async (accessToken, refreshToken, profile, done) => {
		const existingUser = await User.findOne({ googleId: profile.id });
		if (existingUser)
			return done(null, existingUser);

		/**
		 * create MODEL INSTANCE and sav it into mongodb
		 * the user model instance inside then is considered to be more up-todate then the instance 
		 * created by 'new User' although they are both referring to the same record inside mongodb
		 */
		const user = await new User({ googleId: profile.id }).save();
		done(null, user);

	})
);
